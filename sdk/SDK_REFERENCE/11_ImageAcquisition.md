# 11. Image Acquisition and Download

## Overview
This section covers functions required to retrieve the captured image from the camera's internal buffer to the host computer. This is the final step in the synchronous capture+download loop required for plate-solving.

**State Requirement:** **S3 (Session)**, and the **Release operation must be complete** (checked via `XSDK_GetReleaseStatus`).

---

## The In-Camera Buffer

Fujifilm cameras use a temporary, volatile buffer to store the captured image immediately after shutter release. This buffer is distinct from the images stored on the SD card.

- **Volatile Memory:** Images in this buffer are lost if the camera powers off or the session is closed improperly.
- **Order:** Images are stored First-In, First-Out (FIFO). Downloading the current image moves the pointer, making the next image available.

---

## Key Download Functions

### 1. XSDK_ReadImageInfo
- **Purpose:** Gets metadata about the image currently at the top of the camera's volatile buffer.
- **Use Case:** Check if an image is available *before* attempting transfer. Confirms buffer contains data from the current capture.
- **Signature (Inferred):** `LRESULT XSDK_ReadImageInfo(XSDK_HANDLE hCamera, XSDK_ImageInformation* pImageInfo);`

### 2. XSDK_ReadImage (The Download Command)
- **Purpose:** Downloads the full, uncompressed/RAW image data from the camera buffer to the host machine. **Crucially, this also deletes the image from the camera buffer.**
- **Signature (Inferred/Contextual):** `LRESULT XSDK_ReadImage(XSDK_HANDLE hCamera, LPCSTR pOutputDirectory, LPCSTR pFileName);`
    *   *Note*: Our C wrapper `fm_download_last` abstracts the naming/error loop and likely calls this function passing the desired output path and filename.
- **Data Format:** Downloads the original file format (e.g., .RAF) directly.

### 3. XSDK_DeleteImage
- **Purpose:** Removes the top image from the buffer **without** downloading it.
- **Use Case:** Useful if an unwanted image was accidentally captured or if only a preview was needed.

---

## Synchronous Download Pattern (MVP Flow)

This pattern ensures the download happens immediately after capture validation:

```c
// 1. Capture is triggered via XSDK_Release, which completes when image is in buffer.
// 2. Poll for Release Status (from 10_ReleaseControl.md) until complete.

// 3. Check Buffer Availability
XSDK_ImageInformation imgInfo;
if (XSDK_ReadImageInfo(hCamera, &imgInfo) == XSDK_COMPLETE) {
    
    // Determine target path from config/session manager
    const char* outDir = "C:\\path\\to\\capture";
    const char* fileName = "snap_001.RAF"; // Generated by session manager

    // 4. Download Image
    LRESULT res = XSDK_ReadImage(hCamera, outDir, fileName);

    if (res == XSDK_COMPLETE) {
        printf("Download successful: %s/%s\n", outDir, fileName);
        // Proceed to next capture or cleanup
    } else {
        // Download failed (e.g., disk full, permission error, or buffer empty)
        HandleError(hCamera, "XSDK_ReadImage"); 
    }

} else {
    // Buffer empty or error reading info - likely camera error or already downloaded
    HandleError(hCamera, "XSDK_ReadImageInfo");
}
```

---

## Buffer Capacity

### XSDK_GetBufferCapacity
- **Purpose:** Checks how many images are currently queued in the camera buffer.
- **Usage:** Useful for checking status before download or to prevent buffer overflow if the host stalls.
- **Return Value:** Returns the count of images in the buffer.

---

## Direct Download vs. Last Image API

**Note on C Wrapper Functions:**
Our C wrapper has `fm_download_last`. This function likely encapsulates the entire logic:
1. Call `XSDK_ReadImageInfo` to ensure an image exists and get its ID/Metadata.
2. Call `XSDK_ReadImage` using the required parameters for that specific image.
3. Handle path construction outside the SDK call.

If `fm_download_last` is implemented, use it directly, as it might handle specific camera quirks better than generic `XSDK_ReadImage` calls.
